# Tests for modulo operators
# % = Euclidean modulo (result always has same sign as divisor, non-negative for positive divisor)
# %% = Truncating modulo (result has same sign as dividend)
extern fn assert(value: bool);

# Positive values - both operators give same result
assert(17 % 5 == 2);
assert(17 %% 5 == 2);
assert(15 % 5 == 0);
assert(15 %% 5 == 0);

# Modulo by 1 (always 0)
assert(42 % 1 == 0);
assert(42 %% 1 == 0);

# Zero modulo anything
assert(0 % 5 == 0);
assert(0 %% 5 == 0);

# Power of 2 modulo (common in games)
assert(7 % 4 == 3);
assert(15 % 8 == 7);
assert(16 % 8 == 0);
assert(100 % 16 == 4);

# Various modulo values
assert(10 % 3 == 1);
assert(11 % 3 == 2);
assert(12 % 3 == 0);
assert(13 % 3 == 1);

# Negative dividend - key difference between % and %%
# Euclidean (%) always returns non-negative for positive divisor
# Truncating (%%) returns negative when dividend is negative
assert(-7 % 4 == 1);     # Euclidean: -7 = -2*4 + 1
assert(-7 %% 4 == -3);   # Truncating: -7 = -1*4 + (-3)

assert(-1 % 4 == 3);     # Euclidean
assert(-1 %% 4 == -1);   # Truncating

assert(-10 % 3 == 2);    # Euclidean: -10 = -4*3 + 2
assert(-10 %% 3 == -1);  # Truncating: -10 = -3*3 + (-1)

assert(-17 % 5 == 3);    # Euclidean
assert(-17 %% 5 == -2);  # Truncating

# Negative divisor - Euclidean always returns non-negative
assert(7 % -4 == 3);     # Euclidean: always non-negative
assert(7 %% -4 == 3);    # Truncating: result has sign of dividend

assert(-7 % -4 == 1);    # Euclidean: always non-negative
assert(-7 %% -4 == -3);  # Truncating: result has sign of dividend
