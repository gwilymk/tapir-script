# Tests for spawned tasks that wait
extern fn assert(value: bool);

global step = 0;

fn waiting_task() {
    step = 1;
    wait;
    step = 2;
    wait;
    step = 3;
}

# Task progresses through waits
spawn waiting_task();
assert(step == 0);

wait;  # Frame 1: task runs to first wait, step = 1
assert(step == 1);

wait;  # Frame 2: task continues to second wait, step = 2
assert(step == 2);

wait;  # Frame 3: task finishes, step = 3
assert(step == 3);

# Test wait(n) in spawned task
global wait_n_step = 0;

fn waiting_task_n() {
    wait_n_step = 1;
    wait 3;
    wait_n_step = 2;
}

spawn waiting_task_n();
assert(wait_n_step == 0);

wait;  # Task starts, reaches wait 3
assert(wait_n_step == 1);

wait 2;  # Still waiting (frames 2 and 3 of 3)
assert(wait_n_step == 1);

wait;  # Done waiting, continues
assert(wait_n_step == 2);

# Test wait with variable expression
global expr_step = 0;
global wait_amount = 2;

fn waiting_task_expr() {
    expr_step = 1;
    wait wait_amount;  # wait for value in global variable
    expr_step = 2;
}

spawn waiting_task_expr();
assert(expr_step == 0);

wait;  # Task starts, reaches wait
assert(expr_step == 1);

wait;  # Still waiting (1 of 2)
assert(expr_step == 1);

wait;  # Done waiting
assert(expr_step == 2);

# Test wait with computed expression
global computed_step = 0;

fn waiting_task_computed() {
    computed_step = 1;
    wait 1 + 2;  # wait 3
    computed_step = 2;
}

spawn waiting_task_computed();
wait;
assert(computed_step == 1);
wait 2;  # still waiting
assert(computed_step == 1);
wait;  # done
assert(computed_step == 2);

# Test wait with function result
global fn_step = 0;

fn get_wait_time() -> int {
    return 2;
}

fn waiting_task_fn() {
    fn_step = 1;
    wait get_wait_time();
    fn_step = 2;
}

spawn waiting_task_fn();
wait;
assert(fn_step == 1);
wait;  # still waiting
assert(fn_step == 1);
wait;  # done
assert(fn_step == 2);
