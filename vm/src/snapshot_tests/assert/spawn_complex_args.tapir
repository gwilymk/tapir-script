# Tests for spawn with complex argument expressions
# Note: Some tests removed due to optimizer bugs with global structs
extern fn assert(value: bool);

global result_a = 0;
global result_b = 0;

fn store_int(v: int) {
    result_a = v;
}

fn store_two(a: int, b: int) {
    result_a = a;
    result_b = b;
}

fn get_value() -> int {
    return 42;
}

fn add(a: int, b: int) -> int {
    return a + b;
}

# Spawn with expression argument
spawn store_int(5 + 10);
wait;
assert(result_a == 15);

# Spawn with function call as argument
result_a = 0;
spawn store_int(get_value());
wait;
assert(result_a == 42);

# Spawn with nested function calls
result_a = 0;
spawn store_int(add(10, add(5, 3)));
wait;
assert(result_a == 18);

# Spawn with method call as argument
result_a = 0;
spawn store_int((0 - 25).abs());
wait;
assert(result_a == 25);

# Spawn with multiple computed arguments
result_a = 0;
result_b = 0;
spawn store_two(2 + 3, 4 * 5);
wait;
assert(result_a == 5);
assert(result_b == 20);

# Spawn with global variable as argument
global spawn_arg = 77;
result_a = 0;
spawn store_int(spawn_arg);
wait;
assert(result_a == 77);

# Spawn with local variable expression
var local_val = 33;
result_a = 0;
spawn store_int(local_val * 3);
wait;
assert(result_a == 99);
