# Event Type Enum Design

## Problem

Event handlers (`event fn foo(...)` in tapir) currently generate trait methods like `on_foo(&mut self, ...)`. For struct arguments, we need the Rust type name in the function signature, but the compiler only has the tapir struct name/ID - not the corresponding Rust type.

Additionally, the current per-event method approach makes generic script handling harder. You can't easily write code that works with "any script that handles events" without knowing the specific event names at compile time.

## Solution

Make event handlers symmetric with triggers by using a user-defined enum:

```rust
#[tapir("script.tapir", trigger_type = Triggers, event_type = Events)]
struct MyState { ... }

enum Events {
    PlayerHit(Point, i32),  // position, damage
    CollisionDetected(Point),
}
```

Usage:

```rust
// Script<T, E> has send_event method directly - no trait import needed
script.send_event(Events::PlayerHit(position, 10));
script.send_event(Events::CollisionDetected(point));
```

## Naming Convention

Tapir event names use `snake_case`, Rust enum variants use `PascalCase`. The macro converts automatically:

- `event fn player_hit(...)` → `PlayerHit`
- `event fn on_collision(...)` → `OnCollision`

For acronyms, use the standard Rust convention (matches `heck::ToUpperCamelCase`):

- `http_request` → `HttpRequest` (not `HTTPRequest`)
- `xml_parser` → `XmlParser`

Validation happens at Rust compile time - if the enum variant doesn't exist, the generated match arm will fail to compile. Since this is a derive macro, we can't inspect the enum definition ourselves, so we rely on the Rust compiler to catch mismatches.

## Symmetry with Triggers

Triggers should also use this convention. Change from:

```tapir
trigger PlaySound(volume)
```

To:

```tapir
trigger play_sound(volume)
```

With the same `snake_case` → `PascalCase` conversion to match the user's trigger enum variant `PlaySound`.

## Requiring event_type

Using `event fn` without specifying `event_type` in the macro attribute is an error. This should be enforced at compile time via `CompileSettings` - the compiler can check if any event handlers exist and error if `event_type` is not configured.

## Implementation Plan

### Phase 1: Update `TapirScript` trait and `Script` struct

**vm/src/lib.rs:**

1. Rename `EventType` to `TriggerType` for clarity (triggers go OUT from script)
2. Add `pub enum NoEventType {}` - an uninhabited type that can't be constructed
3. Add new `EventType` associated type (events come IN to script), defaulting to `NoEventType`
4. Make `Script<T>` become `Script<T, E = NoEventType>` where E is the event type
5. Add `send_event` method directly on `Script` - no generated trait needed!
6. Add `handle_event` method to `TapirScript` trait that converts event to (stack, pc)

```rust
/// Uninhabited type used as default EventType for scripts with no event handlers.
/// Since this enum has no variants, it's impossible to construct, preventing
/// accidental calls to send_event on scripts that don't handle events.
pub enum NoEventType {}

pub unsafe trait TapirScript {
    type TriggerType;  // renamed from EventType
    type EventType;    // new: for incoming events, default NoEventType

    fn script(self) -> Script<Self, Self::EventType>
    where
        Self: Sized;

    /// Convert an event enum variant to stack data and bytecode offset.
    /// Generated by macro - matches on event, writes args via ConvertBetweenTapir.
    /// Writes to the provided stack (which already has return placeholder) and returns pc.
    fn handle_event(event: Self::EventType, stack: &mut Vec<i32>) -> usize;

    // ... rest unchanged
}

pub struct Script<T: TapirScript, E = NoEventType> {
    vm: Vm<'static>,
    pub properties: T,
    _event_type: core::marker::PhantomData<E>,
}

impl<T: TapirScript<EventType = E>, E> Script<T, E> {
    /// Send an event to the script, triggering the corresponding event handler.
    pub fn send_event(&mut self, event: E) {
        let mut stack = Vec::new();
        stack.push(-1); // return placeholder
        let pc = T::handle_event(event, &mut stack);
        unsafe { self.__private_trigger_event(stack, pc); }
    }
}
```

This approach means no generated trait is needed - `Script` has the `send_event` method directly, and it delegates to the macro-generated `handle_event` on the `TapirScript` trait. The stack is reusable if we later add a pooling mechanism.

### Phase 2: Update macro attribute parsing

**tapir-script-macros-core/src/lib.rs:**

1. Add `event_type: Option<syn::Path>` to `TopLevelTapirArgs`
2. Parse `event_type = MyEventEnum` syntax (same as `trigger_type`)
3. Pass `has_event_type: bool` to `CompileSettings`

### Phase 3: Compiler validation

**compiler/src/compile.rs:**

1. Add `has_event_type: bool` to `CompileSettings`
2. In compilation, if `event_handlers` is non-empty and `!has_event_type`, emit error:
   ```
   error: Script contains event handlers but no event_type was specified.
          Add `event_type = MyEventEnum` to your #[tapir(...)] attribute.
   ```

**Note for LSP:** The LSP should always pass `has_event_type: true` to the compiler. The LSP doesn't know whether the Rust code has `event_type` specified, so it should be permissive and allow `event fn` declarations. The actual validation happens at Rust compile time via the macro.

### Phase 4: Generate `handle_event` implementation

**tapir-script-macros-core/src/lib.rs:**

1. Add `heck` crate dependency for `ToUpperCamelCase`
2. Replace `generate_event_handlers` to generate `handle_event` for the `TapirScript` trait:

```rust
fn generate_handle_event(
    event_handlers: &[compiler::EventHandler],
    event_type: &syn::Path,
) -> TokenStream {
    use heck::ToUpperCamelCase;

    let match_arms: Vec<_> = event_handlers
        .iter()
        .map(|handler| {
            let variant_name = format_ident!("{}", handler.name.to_upper_camel_case());
            let arg_names: Vec<_> = (0..handler.arguments.len())
                .map(|i| format_ident!("arg{}", i))
                .collect();

            let stack_writes = arg_names.iter().map(|arg| {
                quote! {
                    ::tapir_script::ConvertBetweenTapir::write_to_tapir_vec(&#arg, __stack);
                }
            });

            let pc = handler.bytecode_offset;

            quote! {
                #event_type::#variant_name(#(#arg_names),*) => {
                    #(#stack_writes)*
                    #pc
                }
            }
        })
        .collect();

    quote! {
        fn handle_event(__event: #event_type, __stack: &mut ::tapir_script::__private::Vec<i32>) -> usize {
            match __event {
                #(#match_arms)*
            }
        }
    }
}
```

3. This gets included in the `TapirScript` impl, not as a separate trait
4. If `event_type` is `None` and there are event handlers, the compiler already errored
5. If `event_type` is `None` and no event handlers, generate impl with `NoEventType`:

```rust
fn handle_event(event: ::tapir_script::NoEventType, _: &mut Vec<i32>) -> usize {
    match event {}  // empty match on uninhabited type - can never be called
}
```

### Phase 5: Update trigger syntax (separate PR recommended)

**compiler/src/grammar.lalrpop:**

1. Change trigger syntax from `trigger PlaySound(...)` to `trigger play_sound(...)`
2. Update any existing tests/examples

**tapir-script-macros-core/src/lib.rs:**

1. Apply same `to_upper_camel_case()` conversion to trigger names

### Phase 6: Update generated code structure

The full generated code structure becomes:

```rust
// TapirScript impl - now includes handle_event
unsafe impl TapirScript for MyState {
    type TriggerType = Triggers;  // renamed from EventType
    type EventType = Events;      // new

    fn script(self) -> Script<Self, Self::EventType> { ... }

    fn handle_event(event: Events, __stack: &mut Vec<i32>) -> usize {
        match event {
            Events::PlayerHit(arg0, arg1) => {
                ::tapir_script::ConvertBetweenTapir::write_to_tapir_vec(&arg0, __stack);
                ::tapir_script::ConvertBetweenTapir::write_to_tapir_vec(&arg1, __stack);
                PLAYER_HIT_PC
            }
            Events::CollisionDetected(arg0) => {
                ::tapir_script::ConvertBetweenTapir::write_to_tapir_vec(&arg0, __stack);
                COLLISION_DETECTED_PC
            }
        }
    }

    // ... rest unchanged (set_prop, get_prop, create_event, extern_call)
}

// No separate trait needed! Script::send_event calls T::handle_event directly.
// Usage: script.send_event(Events::PlayerHit(pos, 10));
```

### Dependencies to add

**tapir-script-macros-core/Cargo.toml:**

```toml
heck = "0.5"
```

### Migration notes

- Rename all `trigger Foo(...)` to `trigger foo(...)` in tapir files
- Add `event_type = MyEnum` to any `#[tapir(...)]` using `event fn`
- Change calls from `script.on_foo(x)` to `script.send_event(Events::Foo(x))`
- Remove any imports of the generated `*Events` trait (no longer generated)
