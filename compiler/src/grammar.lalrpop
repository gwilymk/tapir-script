use crate::{
    tokens::{
        FileId, LexicalError, Token, Span,
    },
    ast::*,
    reporting::{DiagnosticMessage, Diagnostics, ErrorKind},
    types::Type,
};

use num_traits::Num;

grammar<'input>(file_id: FileId, diagnostics: &mut Diagnostics);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        wait => Token::KeywordWait,
        var => Token::KeywordVar,
        "if" => Token::KeywordIf,
        "extern" => Token::KeywordExtern,
        "else" => Token::KeywordElse,
        "fn" => Token::KeywordFn,
        t_integer => Token::KeywordInt,
        t_fix => Token::KeywordFix,
        t_bool => Token::KeywordBool,
        return => Token::KeywordReturn,
        spawn => Token::KeywordSpawn,
        loop => Token::KeywordLoop,
        break => Token::KeywordBreak,
        continue => Token::KeywordContinue,
        event => Token::KeywordEvent,
        then => Token::KeywordThen,
        trigger => Token::KeywordTrigger,
        global => Token::KeywordGlobal,
        property => Token::KeywordProperty,
        builtin => Token::KeywordBuiltin,
        "struct" => Token::KeywordStruct,
        "self" => Token::KeywordSelf,
        t_task => Token::KeywordTask,

        identifier => Token::Identifier(<&'input str>),
        integer => Token::Integer(<&'input str>),
        fix => Token::Fix(<&'input str>),
        doc_comment => Token::DocComment(<&'input str>),

        true => Token::True,
        false => Token::False,

        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "(" => Token::LParen,
        ")" => Token::RParen,
        ";" => Token::Semicolon,
        "=" => Token::Assign,
        ":" => Token::Colon,
        "->" => Token::Arrow,
        "," => Token::Comma,

        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
        "%" => Token::OperatorMod,
        "//" => Token::OperatorRealDiv,
        "%%" => Token::OperatorRealMod,
        "==" => Token::OperatorEqEq,
        "!=" => Token::OperatorNeEq,
        ">" =>  Token::OperatorGt,
        ">=" => Token::OperatorGtEq,
        "<" =>  Token::OperatorLt,
        "<=" => Token::OperatorLtEq,
        "||" => Token::OperatorOr,
        "&&" => Token::OperatorAnd,
        "<<" => Token::OperatorShl,
        ">>" => Token::OperatorShr,
        "&" => Token::OperatorBitAnd,
        "|" => Token::OperatorBitOr,
        "." => Token::Dot,
    }
}

pub Script: Script<'input> = <TopLevelStatement*> => Script::from_top_level(<>, file_id);

DocComments: Option<String> = {
    () => None,
    <comments: doc_comment+> => Some(comments.join("\n")),
};

TopLevelStatement: TopLevelStatement<'input> = {
    <Statement> => TopLevelStatement::Statement(<>),
    <FunctionDefinition> => TopLevelStatement::FunctionDefinition(<>),
    <ExternFunctionDefinition> => TopLevelStatement::ExternFunctionDefinition(<>),
    <BuiltinFunctionDecl> => TopLevelStatement::BuiltinFunctionDefinition(<>),
    <GlobalDecl> => TopLevelStatement::GlobalDeclaration(<>),
    <PropertyDecl> => TopLevelStatement::PropertyDeclaration(<>),
    <StructDecl> => TopLevelStatement::StructDeclaration(<>),
    <error: !> => {
        diagnostics.add_lalrpop(<>.error, file_id);
        TopLevelStatement::Error
    },
}

GlobalDecl: GlobalDeclaration<'input> = {
    // Initialized global: global name = expr; or global name: type = expr;
    <doc:DocComments> <start:@L> global <name:TypedIdentifier> "=" <value:Expression> ";" <end:@R> =>
        GlobalDeclaration { doc_comment: doc, name, value: Some(value), span: Span::new(file_id, start, end) },

    // Uninitialized global: global name: type; (type is required for uninitialized globals)
    <doc:DocComments> <start:@L> global <name:TypedIdentifierRequired> ";" <end:@R> =>
        GlobalDeclaration { doc_comment: doc, name, value: None, span: Span::new(file_id, start, end) },
}

PropertyDecl: PropertyDeclaration<'input> = {
    <doc:DocComments> <start:@L> property <name:TypedIdentifierRequired> ";" <end:@R> =>
        PropertyDeclaration { doc_comment: doc, name, span: Span::new(file_id, start, end) },
}

StructDecl: StructDeclaration<'input> = {
    <doc:DocComments> <start:@L> "struct" <name:Type> "{" <fields:CommaSeparated<TypedIdentifierRequired>> "}" <end:@R> =>
        StructDeclaration { doc_comment: doc, name, fields, span: Span::new(file_id, start, end) },
}

BuiltinFunctionDecl: BuiltinFunction<'input> = {
    // Regular builtin: builtin(id) fn name(...) -> ret;
    <doc:DocComments> builtin "(" <builtin_id: BuiltinId> ")" "fn" <start: @L> <name: identifier> <end: @R> "(" <arguments: FunctionArguments> ")" <return_type: FunctionReturn> ";" =>
        BuiltinFunction { doc_comment: doc, receiver_type: None, name, builtin_id, arguments, return_type, span: Span::new(file_id, start, end), meta: Metadata::new() },

    // Builtin method: builtin(id) fn Type.name(...) -> ret;
    <doc:DocComments> builtin "(" <builtin_id: BuiltinId> ")" "fn" <receiver: TypeIdentifier> "." <start: @L> <name: identifier> <end: @R> "(" <arguments: MethodArguments> ")" <return_type: FunctionReturn> ";" =>
        BuiltinFunction { doc_comment: doc, receiver_type: Some(receiver), name, builtin_id, arguments, return_type, span: Span::new(file_id, start, end), meta: Metadata::new() },
}

BuiltinId: BuiltinFunctionId = {
    <value: integer> => match value.parse::<i16>() {
        Ok(id) => BuiltinFunctionId(id),
        Err(_) => BuiltinFunctionId(0), // Error handling could be improved
    },
}

FunctionDefinition: Function<'input> = {
    // Regular function: fn name(...) { ... }
    <doc:DocComments> <modifiers: FunctionModifiers> "fn" <start: @L> <name: identifier> <end: @R> "(" <arguments: FunctionArguments> ")" <return_types: FunctionReturn> <statements: Block> =>
        Function { doc_comment: doc, kind: FunctionKind::Regular, name, arguments, return_types, statements, span: Span::new(file_id, start, end), modifiers, meta: Metadata::new() },

    // Method: fn Type.name(...) { ... }
    <doc:DocComments> <modifiers: FunctionModifiers> "fn" <receiver: TypeIdentifier> "." <start: @L> <name: identifier> <end: @R> "(" <arguments: MethodArguments> ")" <return_types: FunctionReturn> <statements: Block> =>
        Function { doc_comment: doc, kind: FunctionKind::Method { receiver_type: receiver }, name, arguments, return_types, statements, span: Span::new(file_id, start, end), modifiers, meta: Metadata::new() },

    // Operator: fn LeftType op RightType(...) { ... }
    <doc:DocComments> <modifiers: FunctionModifiers> "fn"
    <left_type: TypeIdentifier>
    <start: @L> <op: OverloadableOp> <end: @R>
    <right_type: TypeIdentifier>
    "(" <arguments: OperatorArguments> ")" <return_types: FunctionReturn> <statements: Block> =>
        Function {
            doc_comment: doc,
            kind: FunctionKind::Operator(OperatorDef { left_type, op, right_type }),
            name: "",
            arguments,
            return_types,
            statements,
            span: Span::new(file_id, start, end),
            modifiers,
            meta: Metadata::new(),
        },
}

// Operators that can be overloaded
OverloadableOp: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
    "*" => BinaryOperator::Mul,
    "/" => BinaryOperator::Div,
    "%" => BinaryOperator::Mod,
    "//" => BinaryOperator::RealDiv,
    "%%" => BinaryOperator::RealMod,
    "==" => BinaryOperator::EqEq,
    "!=" => BinaryOperator::NeEq,
    "<" => BinaryOperator::Lt,
    "<=" => BinaryOperator::LtEq,
    ">" => BinaryOperator::Gt,
    ">=" => BinaryOperator::GtEq,
}

// Operator arguments: exactly 2 untyped identifiers (types come from pattern)
OperatorArguments: Vec<TypedIdent<'input>> = {
    <left: Identifier> "," <right: Identifier> => vec![
        TypedIdent { ident: left, ty: None },
        TypedIdent { ident: right, ty: None },
    ],
}

ExternFunctionDefinition: ExternFunctionDefinition<'input> = {
    <doc:DocComments> "extern" "fn" <start: @L> <name: identifier> <end: @R> "(" <arguments: FunctionArguments> ")" <return_types: FunctionReturn> ";" =>
        ExternFunctionDefinition { doc_comment: doc, name, arguments, return_types, span: Span::new(file_id, start, end), meta: Metadata::new() },

    <doc:DocComments> "extern" "fn" <start: @L> <name: identifier> <end: @R> "(" <arguments: FunctionArguments> ")" <return_types: FunctionReturn> <block_start: @L> Block <block_end: @R> => {
        let span = Span::new(file_id, block_start, block_end);
        ErrorKind::ExternFunctionWithBlock { name: name.to_string() }
            .at(span, DiagnosticMessage::ExternFunctionCannotHaveBody)
            .emit(diagnostics);
        ExternFunctionDefinition { doc_comment: doc, name, arguments, return_types, span: Span::new(file_id, start, end), meta: Metadata::new() }
    }
}

FunctionModifiers: FunctionModifiers = {
    () => FunctionModifiers::default(),
    <event_start: @L> event <event_end: @R> => FunctionModifiers { is_event_handler: Some(Span::new(file_id, event_start, event_end)) },
}
FunctionArguments: Vec<TypedIdent<'input>> = CommaSeparated<TypedIdentifierRequired>;

// Method arguments: optional self (never typed) followed by regular typed arguments
// self's type is always implicitly the receiver type - no explicit type allowed
// The rule handles: (), (self), (self,), (self, x: int), (self, x: int,), (x: int, y: int)
MethodArguments: Vec<TypedIdent<'input>> = {
    // Just self (instance method with no other args)
    <start:@L> "self" <end:@R> =>
        vec![TypedIdent {
            ident: Ident { ident: "self", span: Span::new(file_id, start, end) },
            ty: None,
        }],

    // self with trailing comma (instance method with no other args)
    <start:@L> "self" <end:@R> "," =>
        vec![TypedIdent {
            ident: Ident { ident: "self", span: Span::new(file_id, start, end) },
            ty: None,
        }],

    // self followed by at least one more argument (uses NonEmptyCommaSeparatedTrailing for trailing comma support)
    <start:@L> "self" <end:@R> "," <rest:NonEmptyCommaSeparatedTrailing<TypedIdentifierRequired>> => {
        let mut args = vec![TypedIdent {
            ident: Ident { ident: "self", span: Span::new(file_id, start, end) },
            ty: None,
        }];
        args.extend(rest);
        args
    },
};

// Non-empty comma-separated list with optional trailing comma
NonEmptyCommaSeparatedTrailing<T>: Vec<T> = {
    <e:T> ","? => vec![e],
    <mut v:(<T> ",")+> <e:T> ","? => {
        v.push(e);
        v
    },
};

// Required type annotation (for function args, properties)
TypedIdentifierRequired: TypedIdent<'input> = {
    <ident: Identifier> ":" <ty: Type> =>
        TypedIdent {
            ident,
            ty: Some(ty),
        },
};
FunctionReturn: FunctionReturn<'input> = {
    <VoidReturn>,
    "->" <start: @L> <t: Type> <end: @R> => FunctionReturn { types: vec![t], span: Span::new(file_id, start, end) },
    "->" "(" <start: @L> <types: CommaSeparated<Type>> <end: @R> ")" => FunctionReturn { types, span: Span::new(file_id, start, end) },
}
VoidReturn: FunctionReturn<'input> = <start: @L> <end: @R> => FunctionReturn { types: vec![], span: Span::new(file_id, start, end) };

CommaSeparated<T>: Vec<T> =
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        },
    };


Type: TypeWithLocation<'input> =
    <start: @L> <type_and_name: TypeWithoutLocation> <end: @R> => TypeWithLocation {
        t: type_and_name.0,
        name: type_and_name.1,
        span: Span::new(file_id, start, end)
    };
TypeWithoutLocation: (Option<Type>, &'input str) = {
    t_integer => (Some(Type::Int), "int"),
    t_bool => (Some(Type::Bool), "bool"),
    t_fix => (Some(Type::Fix), "fix"),
    t_task => (Some(Type::Task), "task"),
    // User-defined types (structs) are parsed as identifiers with t=None,
    // then resolved to Some(Type::Struct(id)) by struct_visitor during compilation.
    <ident: identifier> => (None, ident),
}

Statement: Statement<'input> =
    <start: @L> <kind: StatementKind> <end: @R> => kind.with_span(file_id, start, end);

StatementKind: StatementKind<'input> = {
    var <idents: CommaSeparated<TypedIdentifier>> "=" <values: CommaSeparated<Expression>> ";" => StatementKind::VariableDeclaration { <> },
    <targets: CommaSeparated<Expression>> "=" <values: CommaSeparated<Expression>> ";" => StatementKind::Assignment { <> },
    wait ";" => StatementKind::Wait { frames: None },
    wait <frames: Expression> ";" => StatementKind::Wait { frames: Some(frames) },
    break ";" => StatementKind::Break,
    continue ";" => StatementKind::Continue,

    "if" <condition: Expression> <true_block: Block> <false_block: ElseBlock?> => StatementKind::If {
        condition, true_block, false_block: false_block.unwrap_or_else(Vec::new),
    },
    loop <block: Block> => StatementKind::Loop { <> },

    return <CommaSeparated<Expression>> ";" => StatementKind::Return { values: <> },

    // General expression statement (covers function calls, method calls, spawn, etc.)
    <expr: Expression> ";" => StatementKind::Expression { expression: Box::new(expr) },

    trigger <name: identifier> "(" <arguments: CommaSeparated<Expression>> ")" ";" => StatementKind::Trigger { <> },
    trigger <name: identifier> ";" => StatementKind::Trigger { name, arguments: vec![] },

    <block: Block> => StatementKind::Block { <> },

    <error: !> ";" => {
        diagnostics.add_lalrpop(<>.error, file_id);
        StatementKind::Error
    }
}

Identifier: Ident<'input> =
    <start: @L> <ident: identifier> <end: @R> => Ident { ident, span: Span::new(file_id, start, end) };

// TypeIdentifier accepts identifiers AND builtin type keywords (int, fix, bool, task)
// Used for method receiver types where both struct names and builtin types are valid
TypeIdentifier: Ident<'input> = {
    <start: @L> <ident: identifier> <end: @R> => Ident { ident, span: Span::new(file_id, start, end) },
    <start: @L> t_integer <end: @R> => Ident { ident: "int", span: Span::new(file_id, start, end) },
    <start: @L> t_fix <end: @R> => Ident { ident: "fix", span: Span::new(file_id, start, end) },
    <start: @L> t_bool <end: @R> => Ident { ident: "bool", span: Span::new(file_id, start, end) },
    <start: @L> t_task <end: @R> => Ident { ident: "task", span: Span::new(file_id, start, end) },
};

// Optional type annotation (for var, global)
TypedIdentifier: TypedIdent<'input> = {
    <ident: Identifier> =>
        TypedIdent {
            ident,
            ty: None,
        },
    <ident: Identifier> ":" <ty: Type> =>
        TypedIdent {
            ident,
            ty: Some(ty),
        },
};

Block: Vec<Statement<'input>> = "{" <Statement*> "}";
ElseBlock = "else" <Block>;

Expression: Expression<'input> = {
    #[precedence(level="1")]
    <PostfixExpr>,

    #[precedence(level="2")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> <operator: MulDiv> <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator, rhs: Box::new(rhs) }.with_span(file_id, start, end),

    #[precedence(level="3")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> <operator: AddSub> <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator, rhs: Box::new(rhs) }.with_span(file_id, start, end),

    #[precedence(level="4")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> <operator: Shift> <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator, rhs: Box::new(rhs) }.with_span(file_id, start, end),

    #[precedence(level="5")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> "&" <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator: BinaryOperator::BitAnd, rhs: Box::new(rhs) }.with_span(file_id, start, end),

    #[precedence(level="6")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> "|" <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator: BinaryOperator::BitOr, rhs: Box::new(rhs) }.with_span(file_id, start, end),

    #[precedence(level="7")]
    #[assoc(side="none")]
    <start: @L> <lhs: Expression> <operator: ComparisonOp> <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator, rhs: Box::new(rhs) }.with_span(file_id, start, end),

    #[precedence(level="8")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> "&&" <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator: BinaryOperator::And, rhs: Box::new(rhs) }.with_span(file_id, start, end),

    #[precedence(level="9")]
    #[assoc(side="left")]
    <start: @L> <lhs: Expression> "||" <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator: BinaryOperator::Or, rhs: Box::new(rhs) }.with_span(file_id, start, end),

    #[precedence(level="10")]
    #[assoc(side="none")]
    <start: @L> <lhs: Expression> <operator: then> <rhs: Expression> <end: @R> =>
        ExpressionKind::BinaryOperation { lhs: Box::new(lhs), operator: BinaryOperator::Then, rhs: Box::new(rhs) }.with_span(file_id, start, end),
}

MulDiv: BinaryOperator = {
    "*" => BinaryOperator::Mul,
    "/" => BinaryOperator::Div,
    "//" => BinaryOperator::RealDiv,
    "%%" => BinaryOperator::RealMod,
    "%" => BinaryOperator::Mod,
}

AddSub: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
}

Shift: BinaryOperator = {
    "<<" => BinaryOperator::Shl,
    ">>" => BinaryOperator::Shr,
}

ComparisonOp: BinaryOperator = {
    "==" => BinaryOperator::EqEq,
    "!=" => BinaryOperator::NeEq,
    ">" => BinaryOperator::Gt,
    ">=" => BinaryOperator::GtEq,
    "<" => BinaryOperator::Lt,
    "<=" => BinaryOperator::LtEq,
}

PostfixExpr: Expression<'input> = {
    <Term>,
    // Method call (with parentheses) - must come before field access for precedence
    <start:@L> <receiver:PostfixExpr> "." <method:Identifier> "(" <arguments:CommaSeparated<Expression>> ")" <end:@R> =>
        ExpressionKind::MethodCall { receiver: Box::new(receiver), method, arguments }.with_span(file_id, start, end),
    // Field access (no parentheses)
    <start:@L> <base:PostfixExpr> "." <field:Identifier> <end:@R> =>
        ExpressionKind::FieldAccess { base: Box::new(base), field }.with_span(file_id, start, end),
}

Term: Expression<'input> = {
    "(" <Expression> ")",
    <Num>,
    // Variable reference - either identifier or self keyword
    <start: @L> <ident: identifier> <end: @R> => ExpressionKind::Variable(ident).with_span(file_id, start, end),
    <start: @L> "self" <end: @R> => ExpressionKind::Variable("self").with_span(file_id, start, end),
    <start: @L> <b: Bool> <end: @R> => ExpressionKind::Bool(b).with_span(file_id, start, end),

    <start: @L> <ident: identifier> "(" <arguments: CommaSeparated<Expression>> ")" <end: @R> =>
        ExpressionKind::Call {
            name: ident,
            arguments,
        }.with_span(file_id, start, end),

    // Spawn expression: wraps a function call
    <start: @L> spawn <ident: identifier> "(" <arguments: CommaSeparated<Expression>> ")" <end: @R> =>
        ExpressionKind::Spawn {
            call: Box::new(ExpressionKind::Call {
                name: ident,
                arguments,
            }.with_span(file_id, start, end))
        }.with_span(file_id, start, end),
}

Num: Expression<'input> = {
    <start: @L> <value: integer> <end: @R> => match value.parse::<i32>() {
        Ok(value) => ExpressionKind::Integer(value).with_span(file_id, start, end),
        Err(e) => {
            let span = Span::new(file_id, start, end);
            ErrorKind::InvalidNumber { error: e }
                .at(span, DiagnosticMessage::InvalidInteger)
                .emit(diagnostics);
            ExpressionKind::Error.with_span(file_id, start, end)
        }
    },
    <start: @L> <value: fix> <end: @R> => match Fix::from_str_radix(value, 10) {
        Ok(value) => ExpressionKind::Fix(value).with_span(file_id, start, end),
        Err(_e) => {
            let span = Span::new(file_id, start, end);
            ErrorKind::InvalidFix
                .at(span, DiagnosticMessage::InvalidFixnumLabel)
                .emit(diagnostics);
            ExpressionKind::Error.with_span(file_id, start, end)
        }
    }
}

Bool: bool = {
    true => true,
    false => false,
}