# Complex character animation controller
# Controls a player character with multiple animation states, effects, and interactions

# Struct definitions
struct Vec2 { x: int, y: int }
struct Rect { origin: Vec2, size: Vec2 }
struct Stats { attack: int, defense: int, speed: fix }

# Primitive properties
property sprite_frame: int;
property facing_direction: int;
property health: int;
property is_invincible: bool;
property opacity: fix;
property scale: fix;

# Struct-typed properties
property position: Vec2;
property velocity: Vec2;
property hitbox: Rect;
property player_stats: Stats;

global animation_speed = 4;
global idle_frame_count = 0;
global attack_combo = 0;
global is_attacking = false;
global base_position = Vec2(100, 100);

extern fn play_sound(sound_id: int);
extern fn spawn_particle(x: int, y: int, particle_type: int);
extern fn get_input_x() -> int;
extern fn get_input_y() -> int;
extern fn is_button_pressed(button: int) -> bool;

# Methods on Vec2 struct
fn Vec2.length_squared(self) -> int {
    return self.x * self.x + self.y * self.y;
}

fn Vec2.add(self, other: Vec2) -> Vec2 {
    return Vec2(self.x + other.x, self.y + other.y);
}

fn Vec2.scale(self, factor: int) -> Vec2 {
    return Vec2(self.x * factor, self.y * factor);
}

# Methods on Rect struct
fn Rect.contains(self, point: Vec2) -> bool {
    return point.x >= self.origin.x
        && point.x < self.origin.x + self.size.x
        && point.y >= self.origin.y
        && point.y < self.origin.y + self.size.y;
}

fn Rect.center(self) -> Vec2 {
    return Vec2(
        self.origin.x + self.size.x / 2,
        self.origin.y + self.size.y / 2
    );
}

# Methods on primitive types
fn int.abs(self) -> int {
    if self < 0 {
        return 0 - self;
    }
    return self;
}

fn int.clamp(self, min: int, max: int) -> int {
    if self < min {
        return min;
    }
    if self > max {
        return max;
    }
    return self;
}

fn fix.clamp(self, min: fix, max: fix) -> fix {
    if self < min {
        return min;
    }
    if self > max {
        return max;
    }
    return self;
}

# Main animation loop
spawn idle_animation();
spawn handle_movement();
spawn update_hitbox();

loop {
    # Check for attack input
    if is_button_pressed(0) && is_attacking == false {
        spawn attack_sequence();
    }

    # Update idle counter when not moving
    if get_input_x() == 0 && get_input_y() == 0 {
        idle_frame_count = idle_frame_count + 1;

        # Trigger idle fidget after 120 frames
        if idle_frame_count > 120 {
            trigger IdleFidget;
            idle_frame_count = 0;
        }
    } else {
        idle_frame_count = 0;
    }

    wait;
}

fn idle_animation() {
    var frame = 0;
    loop {
        if is_attacking {
            wait;
            continue;
        }

        sprite_frame = frame;
        frame = (frame + 1) % 4;

        var i = 0;
        loop {
            if i >= animation_speed {
                break;
            }
            wait;
            i = i + 1;
        }
    }
}

fn handle_movement() {
    loop {
        var dx = get_input_x();
        var dy = get_input_y();

        # Update position using struct property
        position.x = position.x + dx * 2;
        position.y = position.y + dy * 2;

        # Use velocity struct
        velocity = Vec2(dx, dy).scale(2);

        # Update facing direction
        if dx > 0 {
            facing_direction = 1;
        } else {
            if dx < 0 {
                facing_direction = -1;
            }
        }

        # ERROR: Type mismatch - trying to assign int to fix property
        if dx != 0 || dy != 0 {
            scale = 105;  # Should be 1.05 for fix type
        }

        wait;
    }
}

fn update_hitbox() {
    loop {
        # Update hitbox origin to follow position
        hitbox.origin = position;

        # Check if player is at base position using method
        var dist_sq = position.add(Vec2(0 - base_position.x, 0 - base_position.y)).length_squared();
        if dist_sq < 100 {
            trigger AtBase;
        }

        wait;
    }
}

fn attack_sequence() {
    is_attacking = true;
    attack_combo = attack_combo + 1;

    # Use player stats for attack calculation
    var damage = player_stats.attack + attack_combo * 2;

    play_sound(1);

    # Attack animation frames
    sprite_frame = 10;
    wait;
    wait;
    sprite_frame = 11;
    spawn_particle(position.x, position.y, 0);
    wait;
    wait;
    sprite_frame = 12;

    # ERROR: Missing semicolon
    trigger AttackHit(attack_combo)

    wait;
    wait;
    wait;

    # Combo window
    var combo_window = 0;
    loop {
        if combo_window >= 15 {
            break;
        }

        if is_button_pressed(0) && attack_combo < 3 {
            spawn attack_sequence();
            return;
        }

        combo_window = combo_window + 1;
        wait;
    }

    attack_combo = 0;
    is_attacking = false;
}

event fn on_damage(amount: int) {
    if is_invincible {
        return;
    }

    # Use defense stat to reduce damage
    var actual_damage = (amount - player_stats.defense).clamp(1, 100);
    health = health - actual_damage;
    play_sound(2);

    # ERROR: Undeclared variable 'damage_taken'
    trigger DamageTaken(damage_taken);

    if health <= 0 {
        spawn death_sequence();
    } else {
        spawn invincibility_frames();
    }
}

fn invincibility_frames() {
    is_invincible = true;

    # Flash effect
    var flashes = 0;
    loop {
        if flashes >= 5 {
            break;
        }

        opacity = 0.3;
        wait;
        wait;
        wait;
        opacity = 1.0;
        wait;
        wait;
        wait;

        flashes = flashes + 1;
    }

    is_invincible = false;
}

fn death_sequence() {
    is_attacking = false;
    play_sound(3);

    # Dramatic pause
    wait;
    wait;
    wait;

    # Fall and fade
    var fall_frames = 0;
    loop {
        if fall_frames >= 30 {
            break;
        }

        position.y = position.y + 1;
        # ERROR: Binary operation between incompatible types (fix - int)
        opacity = opacity - 3;
        scale = scale - 0.02;

        fall_frames = fall_frames + 1;
        wait;
    }

    trigger PlayerDied;
}

event fn on_heal(amount: int) {
    var new_health = health + amount;

    # Cap at max health (100)
    new_health = new_health.clamp(0, 100);

    health = new_health;

    # Healing effect
    spawn_particle(position.x, position.y - 10, 1);
    play_sound(4);

    # Brief scale pulse
    scale = 1.1;
    wait;
    wait;
    scale = 1.0;
}

fn charge_attack() {
    var charge_level = 0;

    loop {
        if is_button_pressed(0) == false {
            break;
        }

        charge_level = charge_level + 1;

        # Visual feedback for charge levels
        if charge_level == 30 {
            scale = 1.1;
            spawn_particle(position.x, position.y, 2);
        }
        if charge_level == 60 {
            scale = 1.2;
            spawn_particle(position.x, position.y, 3);
        }

        wait;
    }

    # Release attack based on charge
    if charge_level >= 60 {
        trigger ChargedAttack(2);
        play_sound(6);
    } else {
        if charge_level >= 30 {
            trigger ChargedAttack(1);
            play_sound(5);
        }
    }

    scale = 1.0;
}

# ERROR: Method on undefined struct
fn Undefined.broken(self) -> int {
    return 0;
}

# ERROR: Wrong self type in method body
fn Vec2.bad_method(self) -> int {
    # ERROR: Trying to access field on wrong type
    return self.nonexistent;
}

fn test_chained_methods() {
    var v = Vec2(3, 4);
    # Chained method calls
    var result = v.add(Vec2(1, 1)).scale(2).length_squared();

    # Method on struct property
    var pos_len = position.length_squared();

    # Method on primitive
    var clamped = health.clamp(0, 100);
    var abs_val = (0 - 5).abs();
}
