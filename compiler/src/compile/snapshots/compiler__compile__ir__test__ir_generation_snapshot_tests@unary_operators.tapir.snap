---
source: compiler/src/compile/ir.rs
expression: output
input_file: compiler/src/compile/snapshot_tests/ir/unary_operators.tapir
---
=======================
fn @toplevel() -> 

---- block 0 ----
return 

=======================
fn test_negation() -> 

---- block 0 ----
temp.13 = int 5
x.2 = temp.13
temp.15 = x.2
temp.14 = -temp.15
y.3 = temp.14
temp.16 = y.3
temp.17 = temp.16
storeprop temp.17, 0
return 

=======================
fn test_logical_not() -> 

---- block 0 ----
temp.18 = bool true
x.4 = temp.18
temp.20 = x.4
temp.19 = !temp.20
y.5 = temp.19
temp.21 = y.5
temp.22 = temp.21
storeprop temp.22, 1
return 

=======================
fn test_bitwise_not() -> 

---- block 0 ----
temp.23 = int 255
x.6 = temp.23
temp.25 = x.6
temp.24 = ~temp.25
y.7 = temp.24
temp.26 = y.7
temp.27 = temp.26
storeprop temp.27, 0
return 

=======================
fn test_unary_in_binary() -> 

---- block 0 ----
temp.28 = int 10
a.8 = temp.28
temp.29 = int 3
b.9 = temp.29
temp.33 = a.8
temp.31 = -temp.33
temp.32 = b.9
temp.30 = temp.31 + temp.32
temp.34 = temp.30
storeprop temp.34, 0
return 

=======================
fn test_chained_unary() -> 

---- block 0 ----
temp.35 = int 5
x.10 = temp.35
temp.38 = x.10
temp.37 = -temp.38
temp.36 = -temp.37
y.11 = temp.36
temp.39 = y.11
temp.40 = temp.39
storeprop temp.40, 0
return 

=======================
fn test_unary_condition() -> 

---- block 3 ----
temp.41 = bool false
x.12 = temp.41
temp.43 = x.12
temp.42 = !temp.43
conditional_jump temp.42 0 1

---- block 0 ----
temp.44 = int 1
temp.45 = temp.44
storeprop temp.45, 0
jmp 2

---- block 1 ----
temp.46 = int 0
temp.47 = temp.46
storeprop temp.47, 0
jmp 2

---- block 2 ----
return
