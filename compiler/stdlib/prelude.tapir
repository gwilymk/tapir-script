# Tapir-script prelude - utility functions available to all scripts

## Returns the sine of x, where x in 0..1 maps to a full circle.
builtin(0) fn sin(x: fix) -> fix;

## Returns the cosine of x, where x in 0..1 maps to a full circle.
builtin(1) fn cos(x: fix) -> fix;

## Returns the square root of x.
builtin(2) fn sqrt(x: fix) -> fix;

## Rounds down to the nearest integer.
builtin(3) fn fix.floor(self) -> int;

## Rounds up to the nearest integer.
builtin(4) fn fix.ceil(self) -> int;

## Rounds to the nearest integer.
builtin(5) fn fix.round(self) -> int;

## Returns the fix with the same value as the given int
builtin(6) fn to_fix(x: int) -> fix;

## Returns the current frame number since script execution started.
builtin(-1) fn frame() -> int;

## Cancels this task, stopping its execution.
builtin(-2) fn task.cancel(self);

## Pauses this task, suspending its execution until resumed.
builtin(-3) fn task.pause(self);

## Resumes a paused task, allowing it to continue execution.
builtin(-4) fn task.resume(self);

## Returns the absolute value.
fn int.abs(self) -> int {
    if self < 0 {
        return 0 - self;
    }

    return self;
}

## Returns the smaller of self and other.
fn int.min(self, other: int) -> int {
    if self < other {
        return self;
    }

    return other;
}

## Returns the larger of self and other.
fn int.max(self, other: int) -> int {
    if self < other {
        return other;
    }

    return self;
}

## Clamps self to the range [min, max].
fn int.clamp(self, min: int, max: int) -> int {
    return self.max(min).min(max);
}

## Returns the absolute value.
fn fix.abs(self) -> fix {
    if self < 0.0 {
        return 0.0 - self;
    }

    return self;
}

## Returns the smaller of self and other.
fn fix.min(self, other: fix) -> fix {
    if self < other {
        return self;
    }

    return other;
}

## Returns the larger of self and other.
fn fix.max(self, other: fix) -> fix {
    if self < other {
        return other;
    }

    return self;
}

## Clamps self to the range [min, max].
fn fix.clamp(self, min: fix, max: fix) -> fix {
    return self.max(min).min(max);
}

## Linearly interpolates between self and other by t (0.0 to 1.0).
fn fix.lerp(self, other: fix, t: fix) -> fix {
    return self + (other - self) * t;
}

## Returns the interpolation factor t such that lerp(self, other, t) == value.
fn fix.inverse_lerp(self, other: fix, value: fix) -> fix {
    return (value - self) / (other - self);
}

## Smooth Hermite interpolation between self and other by t (0.0 to 1.0).
## Produces smoother transitions than lerp with gradual acceleration and deceleration.
fn fix.smoothstep(self, other: fix, t: fix) -> fix {
    var clamped = t.clamp(0.0, 1.0);
    var smooth = clamped * clamped * (3.0 - 2.0 * clamped);
    return self.lerp(other, smooth);
}

## A 2D vector with integer components.
struct int2 {
    x: int,
    y: int,
}

## A 2D vector with fixed-point components.
struct fix2 {
    x: fix,
    y: fix,
}

## Adds two int2 vectors component-wise.
fn int2 + int2(lhs, rhs) -> int2 {
    return int2(lhs.x + rhs.x, lhs.y + rhs.y);
}

## Subtracts two int2 vectors component-wise.
fn int2 - int2(lhs, rhs) -> int2 {
    return int2(lhs.x - rhs.x, lhs.y - rhs.y);
}

## Scales an int2 vector by an integer.
fn int2 * int(lhs, rhs) -> int2 {
    return int2(lhs.x * rhs, lhs.y * rhs);
}

## Scales an int2 vector by an integer.
fn int * int2(lhs, rhs) -> int2 {
    return int2(lhs * rhs.x, lhs * rhs.y);
}

## Divides an int2 vector by an integer.
fn int2 / int(lhs, rhs) -> int2 {
    return int2(lhs.x / rhs, lhs.y / rhs);
}

## Returns the dot product of two vectors.
fn int2.dot(self, other: int2) -> int {
    return self.x * other.x + self.y * other.y;
}

## Returns a vector with absolute values of each component.
fn int2.abs(self) -> int2 {
    return int2(self.x.abs(), self.y.abs());
}

## Returns the squared magnitude (avoids sqrt).
fn int2.magnitude_squared(self) -> int {
    return self.x * self.x + self.y * self.y;
}

## Returns the component-wise product (Hadamard product).
fn int2.hadamard(self, other: int2) -> int2 {
    return int2(self.x * other.x, self.y * other.y);
}

## Returns the 2D cross product (z-component of 3D cross).
fn int2.cross(self, other: int2) -> int {
    return self.x * other.y - self.y * other.x;
}

## Returns a vector with x and y swapped.
fn int2.swap(self) -> int2 {
    return int2(self.y, self.x);
}

## Adds two fix2 vectors component-wise.
fn fix2 + fix2(lhs, rhs) -> fix2 {
    return fix2(lhs.x + rhs.x, lhs.y + rhs.y);
}

## Subtracts two fix2 vectors component-wise.
fn fix2 - fix2(lhs, rhs) -> fix2 {
    return fix2(lhs.x - rhs.x, lhs.y - rhs.y);
}

## Scales a fix2 vector by a fixed-point number.
fn fix2 * fix(lhs, rhs) -> fix2 {
    return fix2(lhs.x * rhs, lhs.y * rhs);
}

## Scales a fix2 vector by a fixed-point number.
fn fix * fix2(lhs, rhs) -> fix2 {
    return fix2(lhs * rhs.x, lhs * rhs.y);
}

## Divides a fix2 vector by a fixed-point number.
fn fix2 / fix(lhs, rhs) -> fix2 {
    return fix2(lhs.x / rhs, lhs.y / rhs);
}

## Returns the dot product of two vectors.
fn fix2.dot(self, other: fix2) -> fix {
    return self.x * other.x + self.y * other.y;
}

## Returns a vector with absolute values of each component.
fn fix2.abs(self) -> fix2 {
    return fix2(self.x.abs(), self.y.abs());
}

## Returns the squared magnitude (avoids sqrt).
fn fix2.magnitude_squared(self) -> fix {
    return self.x * self.x + self.y * self.y;
}

## Returns the magnitude (length) of the vector.
fn fix2.magnitude(self) -> fix {
    return sqrt(self.magnitude_squared());
}

## Returns the component-wise product (Hadamard product).
fn fix2.hadamard(self, other: fix2) -> fix2 {
    return fix2(self.x * other.x, self.y * other.y);
}

## Returns the 2D cross product (z-component of 3D cross).
fn fix2.cross(self, other: fix2) -> fix {
    return self.x * other.y - self.y * other.x;
}

## Returns a vector with x and y swapped.
fn fix2.swap(self) -> fix2 {
    return fix2(self.y, self.x);
}

## Rounds each component to the nearest integer.
fn fix2.round(self) -> int2 {
    return int2(self.x.round(), self.y.round());
}

## Rounds each component down to the nearest integer.
fn fix2.floor(self) -> int2 {
    return int2(self.x.floor(), self.y.floor());
}

## Rounds each component up to the nearest integer.
fn fix2.ceil(self) -> int2 {
    return int2(self.x.ceil(), self.y.ceil());
}

## Returns an approximation of the magnitude (faster but less accurate).
fn fix2.fast_magnitude(self) -> fix {
    var abs = self.abs();
    return 0.960433870103 * abs.x.max(abs.y) + 0.397824734759 * abs.x.min(abs.y);
}

## Returns a unit vector in the same direction.
fn fix2.normalise(self) -> fix2 {
    return self / self.magnitude();
}

## Returns an approximate unit vector (faster but less accurate).
fn fix2.fast_normalise(self) -> fix2 {
    return self / self.fast_magnitude();
}

## Clamps each component to the range [min, max].
fn fix2.clamp(self, min: fix, max: fix) -> fix2 {
    return fix2(self.x.clamp(min, max), self.y.clamp(min, max));
}

## Linearly interpolates between self and other by t (0.0 to 1.0).
fn fix2.lerp(self, other: fix2, t: fix) -> fix2 {
    return self + (other - self) * t;
}

## Smooth Hermite interpolation between self and other by t (0.0 to 1.0).
fn fix2.smoothstep(self, other: fix2, t: fix) -> fix2 {
    var clamped = t.clamp(0.0, 1.0);
    var smooth = clamped * clamped * (3.0 - 2.0 * clamped);
    return self.lerp(other, smooth);
}
